import requests
import os

from dotenv import load_dotenv
from peewee import *
from playhouse.mysql_ext import MySQLDatabase

from flask import Flask, flash, request, redirect, url_for, render_template
from flask import g
from dotenv import load_dotenv


app = Flask(__name__)

load_dotenv('secrets.env')

WAKA_APP_ID = os.getenv('WAKA_APP_ID')
WAKA_APP_SECRET = os.getenv('WAKA_APP_SECRET')
REDIRECT_URI = os.getenv('REDIRECT_URI')

HOST = os.getenv('MYSQL_HOST')
MYSQL_USERNAME = os.getenv('MYSQL_USER')
MYSQL_PASSWORD = os.getenv('MYSQL_PASSWORD')
DB_NAME = os.getenv('MYSQL_DATABASE_NAME')

db = MySQLDatabase(
    host=HOST,
    user=MYSQL_USERNAME,
    password=MYSQL_PASSWORD,
    database=DB_NAME
)


@app.route('/authenticate', methods=['GET'])
def authenticate():
    """
    Authentication endpoint that is redirected to from wakatime authorization page.
    Expects code and state as query parameters, code being the initial access token and state being
    the cryptographically strong state generated in for the URL
    :return: Either redirects to the success page or throws a 400 error back to the user.
    """
    token = request.args.get('code')
    state = request.args.get('state')
    if state_exists(state):
        entry = get_user_data_from_state(state)
        token_response = get_first_token_response(token)

        headers = {'Accept': 'application/x-www-form-urlencoded',
                   'Authorization': 'Bearer {}'.format(token_response['access_token'])}
        response = requests.get('https://wakatime.com/api/v1/users/current', headers=headers)

        if response.status_code == 200:
            user_data = response.json()['data']
            username = user_data['username']
            if create_user_data(entry.discord_username, username, token_response['access_token'],
                                token_response['refresh_token'], entry.server_id):
                return redirect('https://www.immewtable.com/success')

            return {'code': 400, 'error': 'user was probably already created'}, 400

            return {'code': 400, 'error': 'wakatime did not respond with success; try again later'}, 400

    return {'code': 400, 'error': 'state was invalid'}, 400


@app.route('/success', methods=['GET'])
def auth_success():
    """
    Endpoint that the user gets redirected to if the authentication was a success

    :return: Render template for success html
    """
    return render_template('success.html')


@app.route('/', methods=['GET'])
def home():
    """
    Home endpoint (will just redirect to the Github page for now)

    :return: redirect to url
    """
    server = get_user_server('jkc_boi#4751')
    return "Hello, this is the imMewtable home page! " + str(server)


def get_first_token_response(token):
    """
    Calls the wakatime token API to validate the token passed in
    :param token: the first token as generated by wakatime
    :return: The response from the wakatime token API as a dictionary
    """
    headers = {'Accept': 'application/x-www-form-urlencoded'}
    data = {'client_id': WAKA_APP_ID,
            'client_secret': WAKA_APP_SECRET,
            'code': token,
            'grant_type': 'authorization_code',
            'redirect_uri': REDIRECT_URI}

    response = requests.post(url='https://wakatime.com/oauth/token', data=data, headers=headers)
    return __parse_raw_response__(response.text)


def __parse_raw_response__(response_text):
    """
    Parses the raw response from the token API into a dictionary
    :param response_text: the token response as a string
    :return: a dictionary that represents the response from the wakatime token API
    """
    # keys and values are separated with & signs
    response_objects = response_text.split('&')
    parsed_response = {}
    for entry in response_objects:
        # split at = to get proper key/value
        kv = entry.split('=')
        parsed_response[kv[0]] = kv[1]

    return parsed_response


class BaseModel(Model):
    """A base model that will use our MySQL database."""
    class Meta:
        database = db


class WakaData(BaseModel):
    discord_username = CharField(null=False, max_length=40)
    wakatime_username = CharField(null=True, max_length=40)
    auth_token = CharField(null=True, max_length=100)
    refresh_token = CharField(null=True, max_length=100)
    server_id = BigIntegerField(null=False)

    class Meta:
        primary_key = CompositeKey('discord_username', 'server_id')


class AuthenticationState(BaseModel):
    discord_username = CharField(null=False, max_length=40)
    server_id = BigIntegerField(null=False)
    state = CharField(null=False, max_length=50)

    class Meta:
        primary_key = CompositeKey('discord_username', 'server_id')


def get_user_server(discord_username):
    db.connect(reuse_if_open=True)
    data = WakaData.get(WakaData.discord_username == discord_username)
    db.close()
    return data.server_id


def state_exists(state):
    """
    Checks the AuthenticationState table to see if the state exists.
    Used to verify the identity for the token authorization URL
    :param state: the state passed in that will be compared to the DB
    :return: True if the state exists, False if not.
    """
    try:
        db.connect(reuse_if_open=True)
        data = AuthenticationState.get(AuthenticationState.state == state)
        if data.discord_username and data.server_id:
            db.close()
            return True
        else:
            db.close()
            return False

    except Exception as e:
        print(e)
        db.close()
        return False


def get_user_data_from_state(state):
    """
    Retrieves the data that is associated with each state in the database.
    :param state: the state used in the OAuth parameter
    :return: The data associated with the state in the AuthenticationState database, or None if it doesn't exist
    """
    try:
        db.connect(reuse_if_open=True)
        data = AuthenticationState.get(AuthenticationState.state == state)
        db.close()
        return data
    except Exception as e:
        print(e)
        db.close()
        return None


def create_user_data(discord_username, wakatime_username, auth_token, refresh_token, server_id):
    """
    Initializes user data from parameters in the WakaData table
    :param discord_username: the discord username as a string (ie, 'john#1234')
    :param wakatime_username: the wakatime username of the user. Can be None/Null if user didn't create account
    :param auth_token: The access token given by the wakatime token API to make authenticated API calls
    :param refresh_token: The refresh token given by the wakatime token API to get new access tokens
    :param server_id: The bigint server ID that the discord_username registered with
    :return: An int representing how many changes were made in the database. 1 is a successful insert.
    """
    db.connect(reuse_if_open=True)

    code = WakaData.create(discord_username=discord_username,
                           server_id=server_id,
                           wakatime_username=wakatime_username,
                           auth_token=auth_token,
                           refresh_token=refresh_token)
    db.close()
    return code


if __name__ == "__main__":
    app.run(host='0.0.0.0')
